// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.25.1
// source: sys.proto

package sysClient

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	UserRpc_Login_FullMethodName       = "/sysClient.UserRpc/Login"
	UserRpc_GetUserList_FullMethodName = "/sysClient.UserRpc/GetUserList"
	UserRpc_GetUserInfo_FullMethodName = "/sysClient.UserRpc/GetUserInfo"
	UserRpc_UpdateUser_FullMethodName  = "/sysClient.UserRpc/UpdateUser"
	UserRpc_DeleteUser_FullMethodName  = "/sysClient.UserRpc/DeleteUser"
	UserRpc_GrantRole_FullMethodName   = "/sysClient.UserRpc/GrantRole"
	UserRpc_GetUserRole_FullMethodName = "/sysClient.UserRpc/GetUserRole"
)

// UserRpcClient is the client API for UserRpc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserRpcClient interface {
	Login(ctx context.Context, in *LoginReq, opts ...grpc.CallOption) (*LoginResp, error)
	GetUserList(ctx context.Context, in *UserListReq, opts ...grpc.CallOption) (*UserListResp, error)
	GetUserInfo(ctx context.Context, in *UerInfoReq, opts ...grpc.CallOption) (*UserInfoResp, error)
	UpdateUser(ctx context.Context, in *UpdateUserReq, opts ...grpc.CallOption) (*UpdateUserResp, error)
	DeleteUser(ctx context.Context, in *DeleteUserReq, opts ...grpc.CallOption) (*DeleteUserResp, error)
	GrantRole(ctx context.Context, in *GrantRoleReq, opts ...grpc.CallOption) (*GrantRoleResp, error)
	GetUserRole(ctx context.Context, in *GetUerRoleReq, opts ...grpc.CallOption) (*GetUerRoleResp, error)
}

type userRpcClient struct {
	cc grpc.ClientConnInterface
}

func NewUserRpcClient(cc grpc.ClientConnInterface) UserRpcClient {
	return &userRpcClient{cc}
}

func (c *userRpcClient) Login(ctx context.Context, in *LoginReq, opts ...grpc.CallOption) (*LoginResp, error) {
	out := new(LoginResp)
	err := c.cc.Invoke(ctx, UserRpc_Login_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userRpcClient) GetUserList(ctx context.Context, in *UserListReq, opts ...grpc.CallOption) (*UserListResp, error) {
	out := new(UserListResp)
	err := c.cc.Invoke(ctx, UserRpc_GetUserList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userRpcClient) GetUserInfo(ctx context.Context, in *UerInfoReq, opts ...grpc.CallOption) (*UserInfoResp, error) {
	out := new(UserInfoResp)
	err := c.cc.Invoke(ctx, UserRpc_GetUserInfo_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userRpcClient) UpdateUser(ctx context.Context, in *UpdateUserReq, opts ...grpc.CallOption) (*UpdateUserResp, error) {
	out := new(UpdateUserResp)
	err := c.cc.Invoke(ctx, UserRpc_UpdateUser_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userRpcClient) DeleteUser(ctx context.Context, in *DeleteUserReq, opts ...grpc.CallOption) (*DeleteUserResp, error) {
	out := new(DeleteUserResp)
	err := c.cc.Invoke(ctx, UserRpc_DeleteUser_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userRpcClient) GrantRole(ctx context.Context, in *GrantRoleReq, opts ...grpc.CallOption) (*GrantRoleResp, error) {
	out := new(GrantRoleResp)
	err := c.cc.Invoke(ctx, UserRpc_GrantRole_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userRpcClient) GetUserRole(ctx context.Context, in *GetUerRoleReq, opts ...grpc.CallOption) (*GetUerRoleResp, error) {
	out := new(GetUerRoleResp)
	err := c.cc.Invoke(ctx, UserRpc_GetUserRole_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserRpcServer is the server API for UserRpc service.
// All implementations must embed UnimplementedUserRpcServer
// for forward compatibility
type UserRpcServer interface {
	Login(context.Context, *LoginReq) (*LoginResp, error)
	GetUserList(context.Context, *UserListReq) (*UserListResp, error)
	GetUserInfo(context.Context, *UerInfoReq) (*UserInfoResp, error)
	UpdateUser(context.Context, *UpdateUserReq) (*UpdateUserResp, error)
	DeleteUser(context.Context, *DeleteUserReq) (*DeleteUserResp, error)
	GrantRole(context.Context, *GrantRoleReq) (*GrantRoleResp, error)
	GetUserRole(context.Context, *GetUerRoleReq) (*GetUerRoleResp, error)
	mustEmbedUnimplementedUserRpcServer()
}

// UnimplementedUserRpcServer must be embedded to have forward compatible implementations.
type UnimplementedUserRpcServer struct {
}

func (UnimplementedUserRpcServer) Login(context.Context, *LoginReq) (*LoginResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}
func (UnimplementedUserRpcServer) GetUserList(context.Context, *UserListReq) (*UserListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserList not implemented")
}
func (UnimplementedUserRpcServer) GetUserInfo(context.Context, *UerInfoReq) (*UserInfoResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserInfo not implemented")
}
func (UnimplementedUserRpcServer) UpdateUser(context.Context, *UpdateUserReq) (*UpdateUserResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUser not implemented")
}
func (UnimplementedUserRpcServer) DeleteUser(context.Context, *DeleteUserReq) (*DeleteUserResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUser not implemented")
}
func (UnimplementedUserRpcServer) GrantRole(context.Context, *GrantRoleReq) (*GrantRoleResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GrantRole not implemented")
}
func (UnimplementedUserRpcServer) GetUserRole(context.Context, *GetUerRoleReq) (*GetUerRoleResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserRole not implemented")
}
func (UnimplementedUserRpcServer) mustEmbedUnimplementedUserRpcServer() {}

// UnsafeUserRpcServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserRpcServer will
// result in compilation errors.
type UnsafeUserRpcServer interface {
	mustEmbedUnimplementedUserRpcServer()
}

func RegisterUserRpcServer(s grpc.ServiceRegistrar, srv UserRpcServer) {
	s.RegisterService(&UserRpc_ServiceDesc, srv)
}

func _UserRpc_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserRpcServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserRpc_Login_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserRpcServer).Login(ctx, req.(*LoginReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserRpc_GetUserList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserRpcServer).GetUserList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserRpc_GetUserList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserRpcServer).GetUserList(ctx, req.(*UserListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserRpc_GetUserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UerInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserRpcServer).GetUserInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserRpc_GetUserInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserRpcServer).GetUserInfo(ctx, req.(*UerInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserRpc_UpdateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserRpcServer).UpdateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserRpc_UpdateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserRpcServer).UpdateUser(ctx, req.(*UpdateUserReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserRpc_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserRpcServer).DeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserRpc_DeleteUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserRpcServer).DeleteUser(ctx, req.(*DeleteUserReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserRpc_GrantRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GrantRoleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserRpcServer).GrantRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserRpc_GrantRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserRpcServer).GrantRole(ctx, req.(*GrantRoleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserRpc_GetUserRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUerRoleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserRpcServer).GetUserRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserRpc_GetUserRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserRpcServer).GetUserRole(ctx, req.(*GetUerRoleReq))
	}
	return interceptor(ctx, in, info, handler)
}

// UserRpc_ServiceDesc is the grpc.ServiceDesc for UserRpc service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserRpc_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sysClient.UserRpc",
	HandlerType: (*UserRpcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Login",
			Handler:    _UserRpc_Login_Handler,
		},
		{
			MethodName: "GetUserList",
			Handler:    _UserRpc_GetUserList_Handler,
		},
		{
			MethodName: "GetUserInfo",
			Handler:    _UserRpc_GetUserInfo_Handler,
		},
		{
			MethodName: "UpdateUser",
			Handler:    _UserRpc_UpdateUser_Handler,
		},
		{
			MethodName: "DeleteUser",
			Handler:    _UserRpc_DeleteUser_Handler,
		},
		{
			MethodName: "GrantRole",
			Handler:    _UserRpc_GrantRole_Handler,
		},
		{
			MethodName: "GetUserRole",
			Handler:    _UserRpc_GetUserRole_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sys.proto",
}

const (
	AppRpc_AppAdd_FullMethodName    = "/sysClient.AppRpc/AppAdd"
	AppRpc_AppInfo_FullMethodName   = "/sysClient.AppRpc/AppInfo"
	AppRpc_AppList_FullMethodName   = "/sysClient.AppRpc/AppList"
	AppRpc_AppUpdate_FullMethodName = "/sysClient.AppRpc/AppUpdate"
	AppRpc_AppDelete_FullMethodName = "/sysClient.AppRpc/AppDelete"
)

// AppRpcClient is the client API for AppRpc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AppRpcClient interface {
	AppAdd(ctx context.Context, in *AddAppReq, opts ...grpc.CallOption) (*AddAppResp, error)
	AppInfo(ctx context.Context, in *AppInfoReq, opts ...grpc.CallOption) (*AppInfoResp, error)
	AppList(ctx context.Context, in *ListAppReq, opts ...grpc.CallOption) (*ListAppResp, error)
	AppUpdate(ctx context.Context, in *UpdateAppReq, opts ...grpc.CallOption) (*UpdateAppResp, error)
	AppDelete(ctx context.Context, in *DeleteAppReq, opts ...grpc.CallOption) (*DeleteAppResp, error)
}

type appRpcClient struct {
	cc grpc.ClientConnInterface
}

func NewAppRpcClient(cc grpc.ClientConnInterface) AppRpcClient {
	return &appRpcClient{cc}
}

func (c *appRpcClient) AppAdd(ctx context.Context, in *AddAppReq, opts ...grpc.CallOption) (*AddAppResp, error) {
	out := new(AddAppResp)
	err := c.cc.Invoke(ctx, AppRpc_AppAdd_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appRpcClient) AppInfo(ctx context.Context, in *AppInfoReq, opts ...grpc.CallOption) (*AppInfoResp, error) {
	out := new(AppInfoResp)
	err := c.cc.Invoke(ctx, AppRpc_AppInfo_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appRpcClient) AppList(ctx context.Context, in *ListAppReq, opts ...grpc.CallOption) (*ListAppResp, error) {
	out := new(ListAppResp)
	err := c.cc.Invoke(ctx, AppRpc_AppList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appRpcClient) AppUpdate(ctx context.Context, in *UpdateAppReq, opts ...grpc.CallOption) (*UpdateAppResp, error) {
	out := new(UpdateAppResp)
	err := c.cc.Invoke(ctx, AppRpc_AppUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appRpcClient) AppDelete(ctx context.Context, in *DeleteAppReq, opts ...grpc.CallOption) (*DeleteAppResp, error) {
	out := new(DeleteAppResp)
	err := c.cc.Invoke(ctx, AppRpc_AppDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AppRpcServer is the server API for AppRpc service.
// All implementations must embed UnimplementedAppRpcServer
// for forward compatibility
type AppRpcServer interface {
	AppAdd(context.Context, *AddAppReq) (*AddAppResp, error)
	AppInfo(context.Context, *AppInfoReq) (*AppInfoResp, error)
	AppList(context.Context, *ListAppReq) (*ListAppResp, error)
	AppUpdate(context.Context, *UpdateAppReq) (*UpdateAppResp, error)
	AppDelete(context.Context, *DeleteAppReq) (*DeleteAppResp, error)
	mustEmbedUnimplementedAppRpcServer()
}

// UnimplementedAppRpcServer must be embedded to have forward compatible implementations.
type UnimplementedAppRpcServer struct {
}

func (UnimplementedAppRpcServer) AppAdd(context.Context, *AddAppReq) (*AddAppResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppAdd not implemented")
}
func (UnimplementedAppRpcServer) AppInfo(context.Context, *AppInfoReq) (*AppInfoResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppInfo not implemented")
}
func (UnimplementedAppRpcServer) AppList(context.Context, *ListAppReq) (*ListAppResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppList not implemented")
}
func (UnimplementedAppRpcServer) AppUpdate(context.Context, *UpdateAppReq) (*UpdateAppResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppUpdate not implemented")
}
func (UnimplementedAppRpcServer) AppDelete(context.Context, *DeleteAppReq) (*DeleteAppResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppDelete not implemented")
}
func (UnimplementedAppRpcServer) mustEmbedUnimplementedAppRpcServer() {}

// UnsafeAppRpcServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AppRpcServer will
// result in compilation errors.
type UnsafeAppRpcServer interface {
	mustEmbedUnimplementedAppRpcServer()
}

func RegisterAppRpcServer(s grpc.ServiceRegistrar, srv AppRpcServer) {
	s.RegisterService(&AppRpc_ServiceDesc, srv)
}

func _AppRpc_AppAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddAppReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppRpcServer).AppAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AppRpc_AppAdd_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppRpcServer).AppAdd(ctx, req.(*AddAppReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppRpc_AppInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppRpcServer).AppInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AppRpc_AppInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppRpcServer).AppInfo(ctx, req.(*AppInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppRpc_AppList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAppReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppRpcServer).AppList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AppRpc_AppList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppRpcServer).AppList(ctx, req.(*ListAppReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppRpc_AppUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAppReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppRpcServer).AppUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AppRpc_AppUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppRpcServer).AppUpdate(ctx, req.(*UpdateAppReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppRpc_AppDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAppReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppRpcServer).AppDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AppRpc_AppDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppRpcServer).AppDelete(ctx, req.(*DeleteAppReq))
	}
	return interceptor(ctx, in, info, handler)
}

// AppRpc_ServiceDesc is the grpc.ServiceDesc for AppRpc service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AppRpc_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sysClient.AppRpc",
	HandlerType: (*AppRpcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AppAdd",
			Handler:    _AppRpc_AppAdd_Handler,
		},
		{
			MethodName: "AppInfo",
			Handler:    _AppRpc_AppInfo_Handler,
		},
		{
			MethodName: "AppList",
			Handler:    _AppRpc_AppList_Handler,
		},
		{
			MethodName: "AppUpdate",
			Handler:    _AppRpc_AppUpdate_Handler,
		},
		{
			MethodName: "AppDelete",
			Handler:    _AppRpc_AppDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sys.proto",
}

const (
	DepartmentRpc_DepartmentAdd_FullMethodName    = "/sysClient.DepartmentRpc/DepartmentAdd"
	DepartmentRpc_DepartmentInfo_FullMethodName   = "/sysClient.DepartmentRpc/DepartmentInfo"
	DepartmentRpc_DepartmentList_FullMethodName   = "/sysClient.DepartmentRpc/DepartmentList"
	DepartmentRpc_DepartmentUpdate_FullMethodName = "/sysClient.DepartmentRpc/DepartmentUpdate"
	DepartmentRpc_DepartmentDelete_FullMethodName = "/sysClient.DepartmentRpc/DepartmentDelete"
)

// DepartmentRpcClient is the client API for DepartmentRpc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DepartmentRpcClient interface {
	DepartmentAdd(ctx context.Context, in *AddDepartmentReq, opts ...grpc.CallOption) (*AddDepartmentResp, error)
	DepartmentInfo(ctx context.Context, in *DepartmentInfoReq, opts ...grpc.CallOption) (*DepartmentInfoResp, error)
	DepartmentList(ctx context.Context, in *ListDepartmentReq, opts ...grpc.CallOption) (*ListDepartmentResp, error)
	DepartmentUpdate(ctx context.Context, in *UpdateDepartmentReq, opts ...grpc.CallOption) (*UpdateDepartmentResp, error)
	DepartmentDelete(ctx context.Context, in *DeleteDepartmentReq, opts ...grpc.CallOption) (*DeleteDepartmentResp, error)
}

type departmentRpcClient struct {
	cc grpc.ClientConnInterface
}

func NewDepartmentRpcClient(cc grpc.ClientConnInterface) DepartmentRpcClient {
	return &departmentRpcClient{cc}
}

func (c *departmentRpcClient) DepartmentAdd(ctx context.Context, in *AddDepartmentReq, opts ...grpc.CallOption) (*AddDepartmentResp, error) {
	out := new(AddDepartmentResp)
	err := c.cc.Invoke(ctx, DepartmentRpc_DepartmentAdd_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *departmentRpcClient) DepartmentInfo(ctx context.Context, in *DepartmentInfoReq, opts ...grpc.CallOption) (*DepartmentInfoResp, error) {
	out := new(DepartmentInfoResp)
	err := c.cc.Invoke(ctx, DepartmentRpc_DepartmentInfo_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *departmentRpcClient) DepartmentList(ctx context.Context, in *ListDepartmentReq, opts ...grpc.CallOption) (*ListDepartmentResp, error) {
	out := new(ListDepartmentResp)
	err := c.cc.Invoke(ctx, DepartmentRpc_DepartmentList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *departmentRpcClient) DepartmentUpdate(ctx context.Context, in *UpdateDepartmentReq, opts ...grpc.CallOption) (*UpdateDepartmentResp, error) {
	out := new(UpdateDepartmentResp)
	err := c.cc.Invoke(ctx, DepartmentRpc_DepartmentUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *departmentRpcClient) DepartmentDelete(ctx context.Context, in *DeleteDepartmentReq, opts ...grpc.CallOption) (*DeleteDepartmentResp, error) {
	out := new(DeleteDepartmentResp)
	err := c.cc.Invoke(ctx, DepartmentRpc_DepartmentDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DepartmentRpcServer is the server API for DepartmentRpc service.
// All implementations must embed UnimplementedDepartmentRpcServer
// for forward compatibility
type DepartmentRpcServer interface {
	DepartmentAdd(context.Context, *AddDepartmentReq) (*AddDepartmentResp, error)
	DepartmentInfo(context.Context, *DepartmentInfoReq) (*DepartmentInfoResp, error)
	DepartmentList(context.Context, *ListDepartmentReq) (*ListDepartmentResp, error)
	DepartmentUpdate(context.Context, *UpdateDepartmentReq) (*UpdateDepartmentResp, error)
	DepartmentDelete(context.Context, *DeleteDepartmentReq) (*DeleteDepartmentResp, error)
	mustEmbedUnimplementedDepartmentRpcServer()
}

// UnimplementedDepartmentRpcServer must be embedded to have forward compatible implementations.
type UnimplementedDepartmentRpcServer struct {
}

func (UnimplementedDepartmentRpcServer) DepartmentAdd(context.Context, *AddDepartmentReq) (*AddDepartmentResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DepartmentAdd not implemented")
}
func (UnimplementedDepartmentRpcServer) DepartmentInfo(context.Context, *DepartmentInfoReq) (*DepartmentInfoResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DepartmentInfo not implemented")
}
func (UnimplementedDepartmentRpcServer) DepartmentList(context.Context, *ListDepartmentReq) (*ListDepartmentResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DepartmentList not implemented")
}
func (UnimplementedDepartmentRpcServer) DepartmentUpdate(context.Context, *UpdateDepartmentReq) (*UpdateDepartmentResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DepartmentUpdate not implemented")
}
func (UnimplementedDepartmentRpcServer) DepartmentDelete(context.Context, *DeleteDepartmentReq) (*DeleteDepartmentResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DepartmentDelete not implemented")
}
func (UnimplementedDepartmentRpcServer) mustEmbedUnimplementedDepartmentRpcServer() {}

// UnsafeDepartmentRpcServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DepartmentRpcServer will
// result in compilation errors.
type UnsafeDepartmentRpcServer interface {
	mustEmbedUnimplementedDepartmentRpcServer()
}

func RegisterDepartmentRpcServer(s grpc.ServiceRegistrar, srv DepartmentRpcServer) {
	s.RegisterService(&DepartmentRpc_ServiceDesc, srv)
}

func _DepartmentRpc_DepartmentAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddDepartmentReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DepartmentRpcServer).DepartmentAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DepartmentRpc_DepartmentAdd_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DepartmentRpcServer).DepartmentAdd(ctx, req.(*AddDepartmentReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DepartmentRpc_DepartmentInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DepartmentInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DepartmentRpcServer).DepartmentInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DepartmentRpc_DepartmentInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DepartmentRpcServer).DepartmentInfo(ctx, req.(*DepartmentInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DepartmentRpc_DepartmentList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDepartmentReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DepartmentRpcServer).DepartmentList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DepartmentRpc_DepartmentList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DepartmentRpcServer).DepartmentList(ctx, req.(*ListDepartmentReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DepartmentRpc_DepartmentUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateDepartmentReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DepartmentRpcServer).DepartmentUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DepartmentRpc_DepartmentUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DepartmentRpcServer).DepartmentUpdate(ctx, req.(*UpdateDepartmentReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DepartmentRpc_DepartmentDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteDepartmentReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DepartmentRpcServer).DepartmentDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DepartmentRpc_DepartmentDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DepartmentRpcServer).DepartmentDelete(ctx, req.(*DeleteDepartmentReq))
	}
	return interceptor(ctx, in, info, handler)
}

// DepartmentRpc_ServiceDesc is the grpc.ServiceDesc for DepartmentRpc service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DepartmentRpc_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sysClient.DepartmentRpc",
	HandlerType: (*DepartmentRpcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DepartmentAdd",
			Handler:    _DepartmentRpc_DepartmentAdd_Handler,
		},
		{
			MethodName: "DepartmentInfo",
			Handler:    _DepartmentRpc_DepartmentInfo_Handler,
		},
		{
			MethodName: "DepartmentList",
			Handler:    _DepartmentRpc_DepartmentList_Handler,
		},
		{
			MethodName: "DepartmentUpdate",
			Handler:    _DepartmentRpc_DepartmentUpdate_Handler,
		},
		{
			MethodName: "DepartmentDelete",
			Handler:    _DepartmentRpc_DepartmentDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sys.proto",
}

const (
	RoleRpc_RoleAdd_FullMethodName             = "/sysClient.RoleRpc/RoleAdd"
	RoleRpc_RoleInfo_FullMethodName            = "/sysClient.RoleRpc/RoleInfo"
	RoleRpc_RoleList_FullMethodName            = "/sysClient.RoleRpc/RoleList"
	RoleRpc_RoleUpdate_FullMethodName          = "/sysClient.RoleRpc/RoleUpdate"
	RoleRpc_RoleDelete_FullMethodName          = "/sysClient.RoleRpc/RoleDelete"
	RoleRpc_RoleGrantPermission_FullMethodName = "/sysClient.RoleRpc/RoleGrantPermission"
)

// RoleRpcClient is the client API for RoleRpc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RoleRpcClient interface {
	RoleAdd(ctx context.Context, in *AddRoleReq, opts ...grpc.CallOption) (*AddRoleResp, error)
	RoleInfo(ctx context.Context, in *RoleInfoReq, opts ...grpc.CallOption) (*RoleInfoResp, error)
	RoleList(ctx context.Context, in *ListRoleReq, opts ...grpc.CallOption) (*ListRoleResp, error)
	RoleUpdate(ctx context.Context, in *UpdateRoleReq, opts ...grpc.CallOption) (*UpdateRoleResp, error)
	RoleDelete(ctx context.Context, in *DeleteRoleReq, opts ...grpc.CallOption) (*DeleteRoleResp, error)
	RoleGrantPermission(ctx context.Context, in *GrantRolePermissionReq, opts ...grpc.CallOption) (*GrantRolePermissionResp, error)
}

type roleRpcClient struct {
	cc grpc.ClientConnInterface
}

func NewRoleRpcClient(cc grpc.ClientConnInterface) RoleRpcClient {
	return &roleRpcClient{cc}
}

func (c *roleRpcClient) RoleAdd(ctx context.Context, in *AddRoleReq, opts ...grpc.CallOption) (*AddRoleResp, error) {
	out := new(AddRoleResp)
	err := c.cc.Invoke(ctx, RoleRpc_RoleAdd_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleRpcClient) RoleInfo(ctx context.Context, in *RoleInfoReq, opts ...grpc.CallOption) (*RoleInfoResp, error) {
	out := new(RoleInfoResp)
	err := c.cc.Invoke(ctx, RoleRpc_RoleInfo_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleRpcClient) RoleList(ctx context.Context, in *ListRoleReq, opts ...grpc.CallOption) (*ListRoleResp, error) {
	out := new(ListRoleResp)
	err := c.cc.Invoke(ctx, RoleRpc_RoleList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleRpcClient) RoleUpdate(ctx context.Context, in *UpdateRoleReq, opts ...grpc.CallOption) (*UpdateRoleResp, error) {
	out := new(UpdateRoleResp)
	err := c.cc.Invoke(ctx, RoleRpc_RoleUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleRpcClient) RoleDelete(ctx context.Context, in *DeleteRoleReq, opts ...grpc.CallOption) (*DeleteRoleResp, error) {
	out := new(DeleteRoleResp)
	err := c.cc.Invoke(ctx, RoleRpc_RoleDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleRpcClient) RoleGrantPermission(ctx context.Context, in *GrantRolePermissionReq, opts ...grpc.CallOption) (*GrantRolePermissionResp, error) {
	out := new(GrantRolePermissionResp)
	err := c.cc.Invoke(ctx, RoleRpc_RoleGrantPermission_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RoleRpcServer is the server API for RoleRpc service.
// All implementations must embed UnimplementedRoleRpcServer
// for forward compatibility
type RoleRpcServer interface {
	RoleAdd(context.Context, *AddRoleReq) (*AddRoleResp, error)
	RoleInfo(context.Context, *RoleInfoReq) (*RoleInfoResp, error)
	RoleList(context.Context, *ListRoleReq) (*ListRoleResp, error)
	RoleUpdate(context.Context, *UpdateRoleReq) (*UpdateRoleResp, error)
	RoleDelete(context.Context, *DeleteRoleReq) (*DeleteRoleResp, error)
	RoleGrantPermission(context.Context, *GrantRolePermissionReq) (*GrantRolePermissionResp, error)
	mustEmbedUnimplementedRoleRpcServer()
}

// UnimplementedRoleRpcServer must be embedded to have forward compatible implementations.
type UnimplementedRoleRpcServer struct {
}

func (UnimplementedRoleRpcServer) RoleAdd(context.Context, *AddRoleReq) (*AddRoleResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleAdd not implemented")
}
func (UnimplementedRoleRpcServer) RoleInfo(context.Context, *RoleInfoReq) (*RoleInfoResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleInfo not implemented")
}
func (UnimplementedRoleRpcServer) RoleList(context.Context, *ListRoleReq) (*ListRoleResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleList not implemented")
}
func (UnimplementedRoleRpcServer) RoleUpdate(context.Context, *UpdateRoleReq) (*UpdateRoleResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleUpdate not implemented")
}
func (UnimplementedRoleRpcServer) RoleDelete(context.Context, *DeleteRoleReq) (*DeleteRoleResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleDelete not implemented")
}
func (UnimplementedRoleRpcServer) RoleGrantPermission(context.Context, *GrantRolePermissionReq) (*GrantRolePermissionResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleGrantPermission not implemented")
}
func (UnimplementedRoleRpcServer) mustEmbedUnimplementedRoleRpcServer() {}

// UnsafeRoleRpcServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RoleRpcServer will
// result in compilation errors.
type UnsafeRoleRpcServer interface {
	mustEmbedUnimplementedRoleRpcServer()
}

func RegisterRoleRpcServer(s grpc.ServiceRegistrar, srv RoleRpcServer) {
	s.RegisterService(&RoleRpc_ServiceDesc, srv)
}

func _RoleRpc_RoleAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddRoleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleRpcServer).RoleAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleRpc_RoleAdd_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleRpcServer).RoleAdd(ctx, req.(*AddRoleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleRpc_RoleInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleRpcServer).RoleInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleRpc_RoleInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleRpcServer).RoleInfo(ctx, req.(*RoleInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleRpc_RoleList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRoleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleRpcServer).RoleList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleRpc_RoleList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleRpcServer).RoleList(ctx, req.(*ListRoleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleRpc_RoleUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRoleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleRpcServer).RoleUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleRpc_RoleUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleRpcServer).RoleUpdate(ctx, req.(*UpdateRoleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleRpc_RoleDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRoleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleRpcServer).RoleDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleRpc_RoleDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleRpcServer).RoleDelete(ctx, req.(*DeleteRoleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleRpc_RoleGrantPermission_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GrantRolePermissionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleRpcServer).RoleGrantPermission(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleRpc_RoleGrantPermission_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleRpcServer).RoleGrantPermission(ctx, req.(*GrantRolePermissionReq))
	}
	return interceptor(ctx, in, info, handler)
}

// RoleRpc_ServiceDesc is the grpc.ServiceDesc for RoleRpc service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RoleRpc_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sysClient.RoleRpc",
	HandlerType: (*RoleRpcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RoleAdd",
			Handler:    _RoleRpc_RoleAdd_Handler,
		},
		{
			MethodName: "RoleInfo",
			Handler:    _RoleRpc_RoleInfo_Handler,
		},
		{
			MethodName: "RoleList",
			Handler:    _RoleRpc_RoleList_Handler,
		},
		{
			MethodName: "RoleUpdate",
			Handler:    _RoleRpc_RoleUpdate_Handler,
		},
		{
			MethodName: "RoleDelete",
			Handler:    _RoleRpc_RoleDelete_Handler,
		},
		{
			MethodName: "RoleGrantPermission",
			Handler:    _RoleRpc_RoleGrantPermission_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sys.proto",
}

const (
	PermissionRpc_PermissionAdd_FullMethodName    = "/sysClient.PermissionRpc/PermissionAdd"
	PermissionRpc_PermissionInfo_FullMethodName   = "/sysClient.PermissionRpc/PermissionInfo"
	PermissionRpc_PermissionList_FullMethodName   = "/sysClient.PermissionRpc/PermissionList"
	PermissionRpc_PermissionUpdate_FullMethodName = "/sysClient.PermissionRpc/PermissionUpdate"
	PermissionRpc_PermissionDelete_FullMethodName = "/sysClient.PermissionRpc/PermissionDelete"
)

// PermissionRpcClient is the client API for PermissionRpc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PermissionRpcClient interface {
	PermissionAdd(ctx context.Context, in *AddPermissionReq, opts ...grpc.CallOption) (*AddPermissionResp, error)
	PermissionInfo(ctx context.Context, in *PermissionInfoReq, opts ...grpc.CallOption) (*PermissionInfoResp, error)
	PermissionList(ctx context.Context, in *ListPermissionReq, opts ...grpc.CallOption) (*ListPermissionResp, error)
	PermissionUpdate(ctx context.Context, in *UpdatePermissionReq, opts ...grpc.CallOption) (*UpdatePermissionResp, error)
	PermissionDelete(ctx context.Context, in *DeletePermissionReq, opts ...grpc.CallOption) (*DeletePermissionResp, error)
}

type permissionRpcClient struct {
	cc grpc.ClientConnInterface
}

func NewPermissionRpcClient(cc grpc.ClientConnInterface) PermissionRpcClient {
	return &permissionRpcClient{cc}
}

func (c *permissionRpcClient) PermissionAdd(ctx context.Context, in *AddPermissionReq, opts ...grpc.CallOption) (*AddPermissionResp, error) {
	out := new(AddPermissionResp)
	err := c.cc.Invoke(ctx, PermissionRpc_PermissionAdd_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *permissionRpcClient) PermissionInfo(ctx context.Context, in *PermissionInfoReq, opts ...grpc.CallOption) (*PermissionInfoResp, error) {
	out := new(PermissionInfoResp)
	err := c.cc.Invoke(ctx, PermissionRpc_PermissionInfo_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *permissionRpcClient) PermissionList(ctx context.Context, in *ListPermissionReq, opts ...grpc.CallOption) (*ListPermissionResp, error) {
	out := new(ListPermissionResp)
	err := c.cc.Invoke(ctx, PermissionRpc_PermissionList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *permissionRpcClient) PermissionUpdate(ctx context.Context, in *UpdatePermissionReq, opts ...grpc.CallOption) (*UpdatePermissionResp, error) {
	out := new(UpdatePermissionResp)
	err := c.cc.Invoke(ctx, PermissionRpc_PermissionUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *permissionRpcClient) PermissionDelete(ctx context.Context, in *DeletePermissionReq, opts ...grpc.CallOption) (*DeletePermissionResp, error) {
	out := new(DeletePermissionResp)
	err := c.cc.Invoke(ctx, PermissionRpc_PermissionDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PermissionRpcServer is the server API for PermissionRpc service.
// All implementations must embed UnimplementedPermissionRpcServer
// for forward compatibility
type PermissionRpcServer interface {
	PermissionAdd(context.Context, *AddPermissionReq) (*AddPermissionResp, error)
	PermissionInfo(context.Context, *PermissionInfoReq) (*PermissionInfoResp, error)
	PermissionList(context.Context, *ListPermissionReq) (*ListPermissionResp, error)
	PermissionUpdate(context.Context, *UpdatePermissionReq) (*UpdatePermissionResp, error)
	PermissionDelete(context.Context, *DeletePermissionReq) (*DeletePermissionResp, error)
	mustEmbedUnimplementedPermissionRpcServer()
}

// UnimplementedPermissionRpcServer must be embedded to have forward compatible implementations.
type UnimplementedPermissionRpcServer struct {
}

func (UnimplementedPermissionRpcServer) PermissionAdd(context.Context, *AddPermissionReq) (*AddPermissionResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PermissionAdd not implemented")
}
func (UnimplementedPermissionRpcServer) PermissionInfo(context.Context, *PermissionInfoReq) (*PermissionInfoResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PermissionInfo not implemented")
}
func (UnimplementedPermissionRpcServer) PermissionList(context.Context, *ListPermissionReq) (*ListPermissionResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PermissionList not implemented")
}
func (UnimplementedPermissionRpcServer) PermissionUpdate(context.Context, *UpdatePermissionReq) (*UpdatePermissionResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PermissionUpdate not implemented")
}
func (UnimplementedPermissionRpcServer) PermissionDelete(context.Context, *DeletePermissionReq) (*DeletePermissionResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PermissionDelete not implemented")
}
func (UnimplementedPermissionRpcServer) mustEmbedUnimplementedPermissionRpcServer() {}

// UnsafePermissionRpcServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PermissionRpcServer will
// result in compilation errors.
type UnsafePermissionRpcServer interface {
	mustEmbedUnimplementedPermissionRpcServer()
}

func RegisterPermissionRpcServer(s grpc.ServiceRegistrar, srv PermissionRpcServer) {
	s.RegisterService(&PermissionRpc_ServiceDesc, srv)
}

func _PermissionRpc_PermissionAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddPermissionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PermissionRpcServer).PermissionAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PermissionRpc_PermissionAdd_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PermissionRpcServer).PermissionAdd(ctx, req.(*AddPermissionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _PermissionRpc_PermissionInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PermissionInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PermissionRpcServer).PermissionInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PermissionRpc_PermissionInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PermissionRpcServer).PermissionInfo(ctx, req.(*PermissionInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _PermissionRpc_PermissionList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPermissionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PermissionRpcServer).PermissionList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PermissionRpc_PermissionList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PermissionRpcServer).PermissionList(ctx, req.(*ListPermissionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _PermissionRpc_PermissionUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePermissionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PermissionRpcServer).PermissionUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PermissionRpc_PermissionUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PermissionRpcServer).PermissionUpdate(ctx, req.(*UpdatePermissionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _PermissionRpc_PermissionDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePermissionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PermissionRpcServer).PermissionDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PermissionRpc_PermissionDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PermissionRpcServer).PermissionDelete(ctx, req.(*DeletePermissionReq))
	}
	return interceptor(ctx, in, info, handler)
}

// PermissionRpc_ServiceDesc is the grpc.ServiceDesc for PermissionRpc service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PermissionRpc_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sysClient.PermissionRpc",
	HandlerType: (*PermissionRpcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PermissionAdd",
			Handler:    _PermissionRpc_PermissionAdd_Handler,
		},
		{
			MethodName: "PermissionInfo",
			Handler:    _PermissionRpc_PermissionInfo_Handler,
		},
		{
			MethodName: "PermissionList",
			Handler:    _PermissionRpc_PermissionList_Handler,
		},
		{
			MethodName: "PermissionUpdate",
			Handler:    _PermissionRpc_PermissionUpdate_Handler,
		},
		{
			MethodName: "PermissionDelete",
			Handler:    _PermissionRpc_PermissionDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sys.proto",
}
